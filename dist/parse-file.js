// Generated by LiveScript 1.5.0
(function(){
  var Node;
  if (global.map == null) {
    import$(global, require('prelude-ls'));
  }
  Node = require('./Node');
  module.exports = function(buff, grammar, done){
    var fileParseLiteral, fileParseOr, fileParseRepeter, fileParseOptional, fileParseReplace, fileParseItem, notEmpty, fileGetLiteral, fileParseSymbol, ast, e;
    if (!buff.length) {
      return done(new Error("File empty"));
    }
    fileParseLiteral = function(it){
      var fileLiteral;
      if (!buff.length) {
        throw new Error('Unexpected end of file');
      }
      fileLiteral = buff.slice(0, it.length);
      if (fileLiteral.toString() === it) {
        buff = buff.slice(fileLiteral.length);
        return new Node('', fileLiteral.toString());
      }
      throw new Error("Unexpected literal: '" + fileLiteral.toString() + "'. Expected: '" + it + "' at '" + buff + "'");
    };
    fileParseOr = function(it){
      var orig, i$, len$, item, b, that, e;
      if (!buff.length) {
        throw new Error('Unexpected end of file');
      }
      orig = Buffer.from(buff);
      for (i$ = 0, len$ = it.length; i$ < len$; ++i$) {
        item = it[i$];
        b = Buffer.from(buff);
        try {
          if (that = fileParseItem(item)) {
            return that;
          }
        } catch (e$) {
          e = e$;
          buff = b;
          continue;
        }
      }
      buff = orig;
      throw new Error("OR: Unexpected literal at: '" + buff.toString().slice(0, 10) + "'");
    };
    fileParseRepeter = function(it){
      var repeter, obj, save, that, e, results$ = [];
      repeter = it.repeter;
      obj = import$({}, it);
      delete obj.repeter;
      if (repeter === '*') {
        save = [];
        try {
          while (that = fileParseItem(obj)) {
            save.push(that);
            results$.push(that);
          }
          return results$;
        } catch (e$) {
          e = e$;
          return save;
        }
      } else if (repeter === '+') {
        save = [];
        save.push(fileParseItem(obj));
        if (!save.length) {
          throw new Error("Repeter: '+' => Must appear at least once : " + JSON.stringify(obj));
        }
        try {
          while (that = fileParseItem(obj)) {
            save.push(that);
          }
          return save;
        } catch (e$) {
          e = e$;
          return save;
        }
      } else if (repeter === '?') {
        try {
          if (that = fileParseItem(obj)) {
            return that;
          }
        } catch (e$) {
          e = e$;
          return false;
        }
      } else {
        return false;
      }
    };
    fileParseOptional = function(it){
      var res, this$ = this;
      delete it.optional;
      res = fileParseItem(it);
      it.optional = true;
      if (isType('Array', res)) {
        each(function(it){
          return it.optional = true;
        }, res);
      } else {
        res.optional = true;
      }
      return res;
    };
    fileParseReplace = function(it){
      var res, this$ = this;
      delete it.replace;
      res = fileParseItem(it);
      it.replace = true;
      if (isType('Array', res)) {
        each(function(it){
          return it.replace = true;
        }, res);
      } else {
        res.replace = true;
      }
      return res;
    };
    fileParseItem = function(it){
      var a;
      a = import$({}, it);
      if (a.optional) {
        return fileParseOptional(a);
      }
      if (a.replace) {
        return fileParseReplace(a);
      }
      switch (false) {
      case it.repeter == null:
        return fileParseRepeter(it);
      case it.symbol == null:
        return fileParseSymbol(it.symbol);
      case it.or == null:
        return fileParseOr(it.or);
      case it.literal == null:
        return fileParseLiteral(it.literal);
      default:
        throw new Error('PAS SYMBOL');
      }
    };
    notEmpty = function(it){
      if (!(it != null && it.length)) {
        return false;
      }
      return it;
    };
    fileGetLiteral = function(it){
      var i$, ref$, len$, k, item, results$ = [];
      for (i$ = 0, len$ = (ref$ = it.children).length; i$ < len$; ++i$) {
        k = i$;
        item = ref$[i$];
        if ((item != null ? item.literal : void 8) != null && (it != null ? it.literal : void 8) != null) {
          results$.push(it.literal += item.literal);
        }
      }
      return results$;
    };
    fileParseSymbol = function(symbol){
      var node, res, ref$;
      symbol == null && (symbol = 'S');
      node = flatten(
      notEmpty(
      compact(
      map(fileParseItem)(
      grammar[symbol]))));
      res = new Node(symbol, '', node);
      fileGetLiteral(res);
      if (!((ref$ = res.children) != null && ref$.length)) {
        return false;
      }
      return res;
    };
    try {
      ast = fileParseSymbol();
    } catch (e$) {
      e = e$;
      return done(new Error(e));
    }
    if (buff.length) {
      return done(new Error("Expected end of file: " + buff));
    }
    return done(null, ast);
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
